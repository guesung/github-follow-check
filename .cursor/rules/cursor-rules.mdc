---
description: 
globs: 
alwaysApply: true
---
# Cursor Rules: GitHubFollowCheck 개발 가이드라인

## 1. 프로젝트 구조 및 파일 위치

- **컴포넌트**: `src/components/` 폴더에 기능별로 분류하여 작성한다.
- **훅(Hooks)**: `src/hooks/` 폴더에 커스텀 훅을 작성한다.
- **API 로직**: `src/services/` 폴더에 GitHub API 관련 로직을 분리한다.
- **타입 정의**: `src/types/` 폴더에 TypeScript 인터페이스와 타입을 정의한다.
- **유틸리티**: `src/utils/` 폴더에 공통 유틸리티 함수를 작성한다.

```
src/
├── components/
│   ├── UserSearch/
│   ├── FollowAnalysis/
│   └── shared/
├── hooks/
├── services/
├── types/
└── utils/
```

## 2. 기술 스택 및 도구

- **프레임워크**: React 18 + TypeScript
- **스타일링**: Tailwind CSS
- **상태 관리**: React useState, useReducer (전역 상태 불필요)
- **HTTP 클라이언트**: Fetch API (GitHub REST API v4)
- **테스트**: React Testing Library + Jest + MSW (API 모킹)
- **빌드**: Vite
- **배포**: Vercel 또는 Netlify

## 3. 코딩 스타일 및 컨벤션

### 3.1 컴포넌트 작성
- **함수형 컴포넌트**를 기본으로 사용하고, 명명은 PascalCase를 따른다.
- **커스텀 훅**은 `use` 접두사를 사용하고, camelCase로 작성한다.
- **Props 인터페이스**는 컴포넌트명 + `Props`로 명명한다.

```tsx
// 올바른 예시
interface UserSearchProps {
  onSearch: (username: string) => void;
  isLoading: boolean;
}

const UserSearch: React.FC<UserSearchProps> = ({ onSearch, isLoading }) => {
  // ...
};
```

### 3.2 GitHub API 처리
- **API 요청**은 services 폴더에서 분리하여 관리한다.
- **에러 처리**는 일관된 형태로 작성한다.
- **Rate Limit** 고려하여 요청 최적화를 한다.

```typescript
// services/githubApi.ts
export interface GitHubUser {
  login: string;
  id: number;
  avatar_url: string;
  html_url: string;
}

export const fetchFollowers = async (username: string): Promise<GitHubUser[]> => {
  const response = await fetch(`https://api.github.com/users/${username}/followers`);
  
  if (!response.ok) {
    throw new Error(`GitHub API Error: ${response.status}`);
  }
  
  return response.json();
};
```

## 4. 테스트 작성 가이드라인

### 4.1 테스트 파일 구조
- 각 컴포넌트/훅과 동일한 폴더에 `.test.tsx` 파일로 작성한다.
- MSW를 사용하여 GitHub API를 모킹한다.

### 4.2 테스트 커버리지
- **정상 동작**: 사용자 검색, 팔로워/팔로잉 목록 표시
- **에러 처리**: 존재하지 않는 사용자, API 에러, 네트워크 오류
- **상태 관리**: 로딩 상태, 빈 데이터, 대량 데이터
- **사용자 상호작용**: 검색, 필터링, 정렬

```tsx
// components/UserSearch/UserSearch.test.tsx
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import { rest } from 'msw';
import { setupServer } from 'msw/node';
import UserSearch from './UserSearch';

const server = setupServer(
  rest.get('https://api.github.com/users/:username', (req, res, ctx) => {
    return res(ctx.json({ login: 'testuser', id: 1 }));
  })
);

describe('UserSearch', () => {
  beforeAll(() => server.listen());
  afterEach(() => server.resetHandlers());
  afterAll(() => server.close());

  it('사용자 이름 입력 후 검색이 가능하다', async () => {
    const mockOnSearch = jest.fn();
    render(<UserSearch onSearch={mockOnSearch} isLoading={false} />);
    
    const input = screen.getByPlaceholderText('GitHub 사용자명 입력');
    const button = screen.getByText('검색');
    
    fireEvent.change(input, { target: { value: 'testuser' } });
    fireEvent.click(button);
    
    await waitFor(() => {
      expect(mockOnSearch).toHaveBeenCalledWith('testuser');
    });
  });
});
```

## 5. 상태 관리 및 데이터 흐름

### 5.1 상태 구조
```typescript
interface FollowAnalysisState {
  user: GitHubUser | null;
  followers: GitHubUser[];
  following: GitHubUser[];
  isLoading: boolean;
  error: string | null;
}
```

### 5.2 커스텀 훅 패턴
```typescript
// hooks/useGitHubFollowAnalysis.ts
export const useGitHubFollowAnalysis = () => {
  const [state, setState] = useState<FollowAnalysisState>(initialState);
  
  const analyzeUser = useCallback(async (username: string) => {
    setState(prev => ({ ...prev, isLoading: true, error: null }));
    
    try {
      const [user, followers, following] = await Promise.all([
        fetchUser(username),
        fetchFollowers(username),
        fetchFollowing(username)
      ]);
      
      setState({
        user,
        followers,
        following,
        isLoading: false,
        error: null
      });
    } catch (error) {
      setState(prev => ({
        ...prev,
        isLoading: false,
        error: error instanceof Error ? error.message : '알 수 없는 오류'
      }));
    }
  }, []);
  
  return { ...state, analyzeUser };
};
```

## 6. 성능 최적화

### 6.1 API 요청 최적화
- **동시 요청**: `Promise.all`을 사용하여 병렬 처리
- **캐싱**: sessionStorage를 활용한 임시 캐싱 (선택적)
- **Debouncing**: 검색 입력 시 불필요한 요청 방지

### 6.2 렌더링 최적화
- **React.memo**: 불필요한 리렌더링 방지
- **useMemo/useCallback**: 계산 비용이 높은 로직 최적화
- **가상화**: 대량의 팔로워 목록 처리 시 react-window 고려

## 7. 에러 처리 및 사용자 경험

### 7.1 에러 타입별 처리
```typescript
const getErrorMessage = (error: unknown): string => {
  if (error instanceof Error) {
    if (error.message.includes('404')) {
      return '존재하지 않는 사용자입니다.';
    }
    if (error.message.includes('403')) {
      return 'API 요청 한도를 초과했습니다. 잠시 후 다시 시도해주세요.';
    }
  }
  return '알 수 없는 오류가 발생했습니다.';
};
```

### 7.2 사용자 피드백
- **로딩 상태**: 스켈레톤 UI 또는 스피너 표시
- **빈 상태**: 의미 있는 안내 메시지
- **에러 상태**: 사용자 친화적인 에러 메시지와 재시도 옵션

## 8. 추가 개발 원칙

- **타입 안전성**: TypeScript strict 모드 사용, any 타입 금지
- **접근성**: semantic HTML, ARIA 속성, 키보드 네비게이션 지원
- **반응형 디자인**: 모바일 우선 접근법으로 Tailwind CSS 활용
- **SEO**: 메타 태그, Open Graph 설정
- **보안**: API rate limit 고려, 사용자 입력 검증

## 9. 코드 품질 도구

- **ESLint**: React, TypeScript 규칙 적용
- **Prettier**: 일관된 코드 포맷팅
- **Husky**: Git hooks를 통한 코드 품질 검사
- **Lighthouse**: 성능, 접근성, SEO 점검